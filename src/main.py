


# `__future__ import annotations`Îäî Ìñ•ÌõÑ ÌååÏù¥Ïç¨ÏóêÏÑú ÌÉÄÏûÖ ÌûåÌä∏Î•º Î¨∏ÏûêÏó¥Ï≤òÎüº Ï≤òÎ¶¨ÌïòÍ≤å Îê† Í≤ÉÏùÑ ÎØ∏Î¶¨ ÏÇ¨Ïö©ÌïòÎäî ÏòµÏÖòÏù¥Îã§.
# Ïù¥Î†áÍ≤å ÌïòÎ©¥ ÌÅ¥ÎûòÏä§ ÎÇ¥Î∂ÄÏóêÏÑú ÏûêÍ∏∞ ÏûêÏã†Ïù¥ÎÇò ÏïÑÏßÅ Ï†ïÏùòÎêòÏßÄ ÏïäÏùÄ ÌÉÄÏûÖÏùÑ ÌÉÄÏûÖ ÌûåÌä∏Î°ú Ïì∏ Ïàò ÏûàÎã§.
from __future__ import annotations

import argparse # cls Î™ÖÎ†πÏñ¥ ÌååÏã± Î™®Îìà
import csv
import datetime
from decimal import Decimal, getcontext # Í∏àÏúµÏóêÏÑú Ï£ºÎ°ú ÏÇ¨Ïö©ÌïòÎäî Í≥†Ï†ïÏÜåÏàòÏ†ê Î™®Îìà
from pathlib import Path
from typing import Dict, List, Tuple

import sys

# Í≥†Ï†ï ÏÜåÏàòÏ†ê Ïó∞ÏÇ∞Ïù∏ DecimalÏùò ÎÇ¥Î∂Ä Í≥ÑÏÇ∞ Ï†ïÎ∞ÄÎèÑÎ•º ÏÜåÏàòÏ†ê 12ÏûêÎ¶¨ÍπåÏßÄ Î≥¥Ïû•
getcontext().prec = 12


DATA_PATH = Path(__file__).resolve().parents[1] / "data" / "trades.csv"
HEADER = ["id", "date", "ticker", "qty", "price", "stop", "note"]

def print_status(positions: Dict[str, Dict[int, Lot]]) -> None:
    print("üü¢ Open Lots\n")
    for ticker in sorted(positions.keys()):
        lots = positions[ticker]
        for lot in lots.values():
            print(
                f"[{ticker:<5}] Lot ID={lot.id} | Qty={lot.qty} | "
                f"In={lot.price:.2f} | Stop={lot.stop:.2f} | "
                f"Risk=${lot.risk():.2f}"
            )


def print_report(positions: Dict[str, Dict[int, Lot]], realized: Dict[str, Decimal]) -> None:
    print("\nüìä Portfolio Summary (by Ticker)\n")
    print("Ticker | Shares | AvgIn | AvgStop | Risk$ | Realized P/L")
    print("-" * 60)

    for ticker, lots in positions.items():
        qty = sum(l.qty for l in lots.values())
        if qty == 0:
            continue
        avg_in = sum(l.qty * l.price for l in lots.values()) / qty
        avg_stop = sum(l.qty * l.stop for l in lots.values()) / qty
        risk = sum(l.risk() for l in lots.values())
        pl = realized[ticker]
        print(
            f"{ticker:<6} | {qty} | {avg_in:.2f} | {avg_stop:.2f} | {risk:.2f} | {pl:.2f}"
        )



class Lot:
    def __init__(self, lot_id: int, ticker: str, qty: Decimal, price: Decimal, stop: Decimal):
        self.id = lot_id
        self.ticker = ticker
        self.qty = qty
        self.price = price
        self.stop = stop

    def risk(self) -> Decimal:
        return (self.price - self.stop) * self.qty


def ensure_csv() -> None:
    DATA_PATH.parent.mkdir(exist_ok=True)
    if not DATA_PATH.exists():
        with DATA_PATH.open("w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(HEADER)


def load_rows() -> List[Dict[str, str]]:
    ensure_csv()
    with DATA_PATH.open() as f:
        reader = csv.DictReader(f) # Ï≤´ Ï§ÑÏùÑ Ìó§ÎçîÎ°ú Ïù∏ÏãùÌïòÍ≥†, Ïù¥ÌõÑ Í∞Å Ï§ÑÏùÑ dictÎ°ú Î∞òÌôòÌïòÎäî Ïù¥ÌÑ∞Î†àÏù¥ÌÑ∞ Í∞ùÏ≤¥
        return list(reader) # Ïù¥ÌÑ∞Î†àÏù¥ÌÑ∞Î•º Í∞ïÏ†úÎ°ú Î™®Îëê ÏÜåÎπÑÌïòÏó¨, Í∞Å Ï§ÑÏùÑ ÎîïÏÖîÎÑàÎ¶¨Î°ú Î≥ÄÌôòÌïú Î¶¨Ïä§Ìä∏ Î∞òÌôò




def next_row_id(rows: List[Dict[str, str]]) -> int:
    if not rows:
        return 1
    return max(int(r["id"]) for r in rows) + 1

"""
"a": append Î™®Îìú ‚Äî Í∏∞Ï°¥ ÌååÏùº ÎÇ¥Ïö©ÏùÑ Ïú†ÏßÄÌïòÎ©¥ÏÑú Îß® ÎÅùÏóê Ï∂îÍ∞Ä
newline="": ÏúàÎèÑÏö∞ ÌôòÍ≤ΩÏóêÏÑú Î∂àÌïÑÏöîÌïú Îπà Ï§Ñ ÏÉùÍπÄ Î∞©ÏßÄ (ÌëúÏ§Ä Í∂åÏû•)
"""
def append_row(row: Dict[str, str]) -> None:
    with DATA_PATH.open("a", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=HEADER)
        writer.writerow(row)


def make_row(row_id: int, date: str, ticker: str, qty: Decimal,
             price: Decimal, stop: Decimal, note: str) -> Dict[str, str]:
    """Í≥µÏö© row ÏÉùÏÑ± Ìó¨Ìçº"""
    return {
        "id": str(row_id),
        "date": date,
        "ticker": ticker,
        "qty": str(qty),
        "price": str(price),
        "stop": str(stop),
        "note": note,
    }


def build_portfolio(rows: List[Dict[str, str]]) -> Tuple[Dict[str, Dict[int, Lot]], Dict[str, Decimal]]:
    """
    Î∞òÌôòÍ∞í ÌäúÌîå)
    positions: {ticker: {row_id: Lot}} ÌòïÌÉú ‚Äî Î≥¥Ïú† Ï§ëÏù∏ \n
    realized: {ticker: ÏàòÏùµ} ÌòïÌÉú ‚Äî Ïã§ÌòÑ ÏàòÏùµÍ∏à
    """

    positions: Dict[str, Dict[int, Lot]] = {}
    realized: Dict[str, Decimal] = {}   

    for r in rows:
        # csv ÏùΩÏùÄ Í∞íÏùÄ Í∏∞Î≥∏Ï†ÅÏúºÎ°ú strÏù¥Í∏∞ ÎïåÎ¨∏Ïóê DecimalÎ°ú Î≥ÄÌôò ÌïÑÏöî
        qty = Decimal(r["qty"])
        price = Decimal(r["price"])
        stop = Decimal(r["stop"])
        ticker = r["ticker"]
        row_id = int(r["id"])
        note = r.get("note", "")

        # dictÏóê ÌÇ§ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í ÏÑ∏ÌåÖ
        positions.setdefault(ticker, {})
        realized.setdefault(ticker, Decimal("0"))



        # csv ÏóêÏÑú qtyÍ∞Ä ÏñëÏàòÏù¥Î©¥ Îß§Ïàò ÏûÖÎ†•, ÏùåÏàòÏù¥Î©¥ Îß§ÎèÑ ÏûÖÎ†•, 0Ïù¥Î©¥ Í∑∏ Î∞ñÏùò Ï≤òÎ¶¨(move stop) 
        if qty > 0:
            # new lot
            positions[ticker][row_id] = Lot(row_id, ticker, qty, price, stop)
        elif qty < 0:
            target = _parse_target_id(note)
            lot = positions[ticker].get(target)
            if not lot:
                continue
            sell_qty = -qty
            if sell_qty > lot.qty:
                sell_qty = lot.qty
            realized[ticker] += sell_qty * (price - lot.price)
            lot.qty -= sell_qty
            if lot.qty == 0:
                del positions[ticker][target]
        else:  # stop move
            target = _parse_target_id(note)
            lot = positions[ticker].get(target)
            if lot:
                lot.stop = stop

    return positions, realized


def _parse_target_id(note: str) -> int:
    for token in note.split():
        if token.startswith("id="):
            try:
                return int(token.split("=", 1)[1]) # '=' Í∏∞Ï§ÄÏúºÎ°ú 1Î≤à Ï™ºÍ∞úÏÑú [1] Ïù∏Îç±Ïä§Î•º Î∞òÌôò
            except ValueError:
                pass
    raise ValueError("target id not found in note")


def cmd_add(args: argparse.Namespace) -> None:
    rows = load_rows()
    row_id = next_row_id(rows)
    date = args.date or datetime.date.today().isoformat() # date Ïù∏ÏûêÍ∞Ä ÏóÜÏúºÎ©¥ Ïò§Îäò ÎÇ†Ïßú ÏÇ¨Ïö©.

    # csv Ï†ÄÏû•ÎêòÍ∏∞ ÏúÑÌïú ÌòïÌÉúÎäî Î∞òÎìúÏãú str
    row = {
        "id": str(row_id),
        "date": date,
        "ticker": args.ticker.upper(),
        "qty": str(Decimal(args.qty)),
        "price": str(Decimal(args.price)),
        "stop": str(Decimal(args.stop)),
        "note": args.note or "",
    }
    append_row(row)
    print(f"Added lot {row_id}")


def cmd_trim(args: argparse.Namespace) -> None:
    rows = load_rows()
    positions, _ = build_portfolio(rows)

    ticker = args.ticker.upper()
    lot = positions.get(ticker, {}).get(args.id)

    # 1) ID Ï°¥Ïû¨ Í≤ÄÏÇ¨
    if not lot:
        print(f"‚ö†Ô∏è Trim skipped: lot id={args.id} for {ticker} not found.")
        return

    sell_qty = Decimal(args.qty)
    # 2) Í≥ºÎã§ Îß§ÎèÑ Î∞©ÏßÄ
    if sell_qty > lot.qty:
        print(f"‚ö†Ô∏è Trim skipped: trying to sell {sell_qty}, but only {lot.qty} left.")
        return

    # 3) Ï†ïÏÉÅ Ï≤òÎ¶¨
    row_id = next_row_id(rows)
    date = args.date or datetime.date.today().isoformat()
    note = f"trim id={args.id}" + (f" {args.note}" if args.note else "")
    row = {
        "id": str(row_id),
        "date": date,
        "ticker": ticker,
        "qty": str(-sell_qty),
        "price": str(Decimal(args.price)),
        "stop": "0",
        "note": note,
    }
    append_row(row)
    print(f"Trimmed lot {args.id} by {sell_qty}")


def cmd_close(args: argparse.Namespace) -> None:
    rows = load_rows()
    positions, _ = build_portfolio(rows)

    ticker = args.ticker.upper()
    lot = positions.get(ticker, {}).get(args.id)


    if not lot:
        print(f"‚ö†Ô∏è Close skipped: lot id={args.id} for {ticker} not found.")
        return
    if lot.qty == 0:
        print(f"‚ö†Ô∏è Close skipped: lot id={args.id} for {ticker} already fully sold.")
        return
    
    # closeÎäî ÌäπÏ†ï Ìä∏ÎûúÏπòÎ•º Ï†ÑÎüâ Ï≤≠ÏÇ∞ÌïòÎäî Í≤ÉÏùÑ ÏùòÎØ∏ÌïòÍ∏∞ ÎïåÎ¨∏Ïóê idÍ∞Ä ÏùºÏπòÌïòÎäî Ìä∏ÎûúÏπòÏùò Ï†ÑÏ≤¥ ÏàòÎüâÏùÑ cmd_trim ÏûÖÎ†•ÏúºÎ°ú ÎÑ£Ïñ¥ ÏΩîÎìúÎ•º Ïû¨ÏÇ¨Ïö©ÌïúÎã§.
    qty = lot.qty
    args_trim = argparse.Namespace(
        ticker=ticker,
        qty=str(qty),
        id=args.id,
        price=args.price,
        note=args.note,
        date=args.date,
    )
    cmd_trim(args_trim)


def cmd_stop(args: argparse.Namespace) -> None:
    rows = load_rows()
    positions, _ = build_portfolio(rows)

    ticker = args.ticker.upper()
    lot = positions.get(ticker, {}).get(args.id)
    
    if not lot:
        print(f"‚ö†Ô∏è Stop skipped: lot id={args.id} for {ticker} not found.")
        return

    row_id = next_row_id(rows)
    date = args.date or datetime.date.today().isoformat()
    note = f"stop id={args.id}" + (f" {args.note}" if args.note else "")
    row = {
        "id": str(row_id),
        "date": date,
        "ticker": ticker,
        "qty": "0",
        "price": "0",
        "stop": str(Decimal(args.new_stop)),
        "note": note,
    }
    append_row(row)
    print(f"Moved stop for lot {args.id} of {ticker}: {lot.stop} ‚ûù {args.new_stop}")


def cmd_split(args: argparse.Namespace) -> None:
    rows = load_rows()
    positions, _ = build_portfolio(rows)

    ticker = args.ticker.upper()
    lot = positions.get(ticker, {}).get(args.id)

    if not lot or lot.qty == 0:
        print(f"‚ö†Ô∏è Split skipped: lot id={args.id} for {ticker} not found or closed.")
        return

    tokens = args.parts.split()
    parts: List[Tuple[Decimal, Decimal]] = []
    for tok in tokens:
        try:
            qty_s, stop_s = tok.split(":", 1)
            parts.append((Decimal(qty_s), Decimal(stop_s)))
        except Exception:
            print(f"‚ö†Ô∏è Split skipped: invalid part '{tok}'.")
            return

    total_qty = sum(q for q, _ in parts)
    if total_qty != lot.qty:
        print(f"‚ö†Ô∏è Split skipped: parts sum {total_qty} ‚â† lot qty {lot.qty}.")
        return

    stops = [s for _, s in parts]
    if len(stops) != len(set(stops)):
        print("‚ö†Ô∏è Split skipped: duplicate stop values.")
        return

    date = args.date or datetime.date.today().isoformat()
    row_id = next_row_id(rows)
    total_rows = len(parts) + 1
    idx = 1

    # A. trim
    trim_qty = lot.qty - parts[0][0]
    note = f"split from id={args.id} part {idx}/{total_rows}"
    rows_to_append = [
        make_row(row_id, date, ticker, -trim_qty, lot.price, Decimal("0"), note)
    ]
    row_id += 1
    idx += 1

    # B. stop move for original lot
    note = f"split from id={args.id} part {idx}/{total_rows}"
    rows_to_append.append(
        make_row(row_id, date, ticker, Decimal("0"), Decimal("0"), parts[0][1], note)
    )
    row_id += 1
    idx += 1

    # C. add new lots
    for qty, stop in parts[1:]:
        note = f"split from id={args.id} part {idx}/{total_rows}"
        rows_to_append.append(
            make_row(row_id, date, ticker, qty, lot.price, stop, note)
        )
        row_id += 1
        idx += 1

    for r in rows_to_append:
        append_row(r)
    print(f"Split lot {args.id} of {ticker} into {len(parts)} parts")
    

def cmd_status(_: argparse.Namespace) -> None:
    rows = load_rows()
    positions, _ = build_portfolio(rows)
    print_status(positions)


def cmd_report(_: argparse.Namespace) -> None:
    rows = load_rows()
    positions, realized = build_portfolio(rows)
    print_report(positions, realized)


def cmd_summary(_: argparse.Namespace) -> None:
    rows = load_rows()
    positions, realized = build_portfolio(rows)
    print_status(positions)
    print_report(positions, realized)

# Ïù¥ Ìï®ÏàòÎäî argparse.ArgumentParser Í∞ùÏ≤¥Î•º ÏÉùÏÑ±Ìï¥ÏÑú Î¶¨ÌÑ¥Ìï®. Ï¶â CLI ÌååÏÑú ÏÉùÏÑ±Í∏∞
def build_parser() -> argparse.ArgumentParser:

    p = argparse.ArgumentParser(
    prog="tradingbook",
    description="TradingBook: A CLI-based portfolio tracking tool for stock traders.",
    epilog="""\
    Examples:
    tradingbook add TSLA 100 200 180                         # Buy 100 shares @200, stop 180
    tradingbook trim TSLA 30 --id 3 --price 220              # Sell 30 shares from lot id=3 @220
    tradingbook close TSLA --id 3 --price 240                # Close entire lot id=3 @240
    tradingbook stop TSLA 190 --id 3                         # Move stop of lot id=3 to 190
    tradingbook split TSLA --id 3 --parts "50:190 50:185"    # Split lot id=3 into two tranches
    tradingbook status                                        # Show all open lots (ID-level view)
    tradingbook report                                        # Show ticker-level portfolio summary
    tradingbook summary                                       # status + report in one shot
    """,
    formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    

    # add, trim, close, stop, report Í∞ôÏùÄ ÏÑúÎ∏å Î™ÖÎ†πÏñ¥Î•º ÏßÄÏõêÌïòÎèÑÎ°ù ÏÑ§Ï†ï
    # dest="command" ‚Üí ÏÇ¨Ïö©ÏûêÍ∞Ä ÏûÖÎ†•Ìïú Î™ÖÎ†πÏñ¥Îäî args.commandÏóê Ï†ÄÏû•Îê®
    # required=True ‚Üí Î∞òÎìúÏãú ÌïòÎÇòÏùò ÏÑúÎ∏å Î™ÖÎ†πÏñ¥Îäî ÏûÖÎ†•Ìï¥Ïïº Ìï®
    sub = p.add_subparsers(dest="command", required=True)

    ### add Î™ÖÎ†πÏñ¥ Ï†ïÏùò
    add_p = sub.add_parser("add", help="Add a new lot (buy)")
    # positional argument (ÌïÑÏàòÏù∏Ïûê, Î∞òÎìúÏãú ÏàúÏÑúÎ•º ÏßÄÏºúÏïº Ìï®)
    add_p.add_argument("ticker", help="Stock ticker symbol (e.g., TSLA)")
    add_p.add_argument("qty", help="Number of shares to buy (e.g., 100)")
    add_p.add_argument("price", help="Entry price per share (e.g., 200.0)")
    add_p.add_argument("stop", help="Initial stop loss price (e.g., 180.0)")

    add_p.add_argument("--note", help="Optional memo or trade note")
    # ÏÑ†ÌÉùÏù∏Ïûê (--arg ÏÇ¨Ïö© ÏãúÏóêÎßå ÏÇ¨Ïö©, ÏàúÏÑú ÏÉÅÍ¥Ä ÏóÜÍ≥† ÏÉùÎûµ Í∞ÄÎä•Ìï®)
    add_p.add_argument("--date", help="Transaction date (YYYY-MM-DD). Defaults to today.")    
    # Ïã§ÌñâÌï®Ïàò Îì±Î°ù
    add_p.set_defaults(func=cmd_add)


    ### trim Î™ÖÎ†πÏñ¥ Îì±Î°ù
    trim_p = sub.add_parser("trim", help="Sell part of a lot (partial exit)")

    trim_p.add_argument("ticker", help="Stock ticker (e.g., TSLA)")
    trim_p.add_argument("qty", help="Quantity to sell (e.g., 30)")
    trim_p.add_argument("--id", required=True, type=int, help="Target lot ID to trim from")
    trim_p.add_argument("--price", required=True, help="Sell price (e.g., 220.5)")
    trim_p.add_argument("--note", help="Optional memo or trade note")
    trim_p.add_argument("--date", help="Execution date (YYYY-MM-DD)")
    trim_p.set_defaults(func=cmd_trim)


    # close Î™ÖÎ†πÏñ¥ Îì±Î°ù
    close_p = sub.add_parser("close", help="Close an entire lot (full exit)")

    close_p.add_argument("ticker", help="Stock ticker (e.g., TSLA)")
    close_p.add_argument("--id", required=True, type=int, help="Lot ID to close")
    close_p.add_argument("--price", required=True, help="Sell price for closing (e.g., 240.0)")
    close_p.add_argument("--note", help="Optional memo or trade note")
    close_p.add_argument("--date", help="Execution date (YYYY-MM-DD)")
    close_p.set_defaults(func=cmd_close)


    # stop Î™ÖÎ†πÏñ¥ Îì±Î°ù
    stop_p = sub.add_parser("stop", help="Move stop loss for a specific lot")

    stop_p.add_argument("ticker", help="Stock ticker (e.g., TSLA)")
    stop_p.add_argument("new_stop", help="New stop loss price (e.g., 190.0)")
    stop_p.add_argument("--id", required=True, type=int, help="Lot ID to update stop for")
    stop_p.add_argument("--note", help="Optional memo or trade note")
    stop_p.add_argument("--date", help="Execution date (YYYY-MM-DD)")
    stop_p.set_defaults(func=cmd_stop)

    # split Î™ÖÎ†πÏñ¥ Îì±Î°ù
    split_p = sub.add_parser("split", help="Split a lot into multiple lots")
    split_p.add_argument("ticker", help="Stock ticker (e.g., TSLA)")
    split_p.add_argument("--id", required=True, type=int, help="Lot ID to split")
    split_p.add_argument(
        "--parts",
        required=True,
        help="Parts as 'QTY:STOP' tokens separated by space",
    )
    split_p.add_argument("--note", help="Optional memo or trade note")
    split_p.add_argument("--date", help="Execution date (YYYY-MM-DD)")
    split_p.set_defaults(func=cmd_split)


    # report Î™ÖÎ†πÏñ¥ Îì±Î°ù
    rep_p = sub.add_parser("report", help="Display portfolio summary and P/L report")
    rep_p.set_defaults(func=cmd_report)


    # status Î™ÖÎ†πÏñ¥ Îì±Î°ù
    stat_p = sub.add_parser("status", help="Display all currently open lots")
    stat_p.set_defaults(func=cmd_status)

    # summary Î™ÖÎ†πÏñ¥ Îì±Î°ù
    sum_p = sub.add_parser("summary", help="Show both status and report")
    sum_p.set_defaults(func=cmd_summary)

    return p


# argv: Î™ÖÏãúÏ†ÅÏúºÎ°ú Ïù∏Ïûê Î¶¨Ïä§Ìä∏Î•º ÎÑòÍ∏∏ Ïàò ÏûàÎèÑÎ°ù ÌååÎùºÎØ∏ÌÑ∞Î°ú Î∞õÏùå
# Í∏∞Î≥∏Í∞íÏùÄ None. Ïù¥ Í≤ΩÏö∞ sys.argvÎ•º ÏûêÎèô ÏÇ¨Ïö©Ìï®
def main(argv: List[str] | None = None) -> None:

    # CLI ÌååÏÑú ÏÉùÏÑ±
    parser = build_parser() 

    # Ïù∏Ïûê Ïã§Ï†úÎ°ú ÌååÏã±Ìï¥ÏÑú ÎÑ§ÏûÑÏä§ÌéòÏù¥Ïä§ Í∞ùÏ≤¥Î°ú Î∞òÌôò
    # ex) tradingbook add TSLA 100 200 180
    # Ïù¥Í±∏ ÏïÑÎûòÏ≤òÎüº 
    #    args = Namespace(
    #       command="add",
    #       ticker="TSLA",
    #       qty="100",
    #       price="200",
    #       stop="180",
    #       note=None,
    #       func=cmd_add
    #    )
    args = parser.parse_args(argv) 

    # Ïó¨Í∏∞ÏÑú CLI Î™ÖÎ†πÏù¥ Ïã§Ï†úÎ°ú Ïã§ÌñâÎê®
    args.func(args)


if __name__ == "__main__":
    main()
